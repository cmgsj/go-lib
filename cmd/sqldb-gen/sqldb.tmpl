package sqldb

import (
	"context"
	"database/sql"

	"{{ . }}"
)

type DB interface {
	sqlc.Querier
	Ping(ctx context.Context) error
	ExecTx(ctx context.Context, f TxFunc) error
	BeginTx(ctx context.Context) (Tx, error)
}

type Tx interface {
	sqlc.Querier
	Rollback() error
	Commit() error
}

type TxFunc func(q sqlc.Querier) error

func New(ctx context.Context, driver, dataSource string) (DB, error) {
	sqlDB, err := sql.Open(driver, dataSource)
	if err != nil {
		return nil, err
	}
	q, err := sqlc.Prepare(ctx, sqlDB)
	if err != nil {
		return nil, err
	}
	return &db{q, q, sqlDB}, nil
}

type db struct {
	sqlc.Querier
	q  *sqlc.Queries
	db *sql.DB
}

func (d *db) Ping(ctx context.Context) error {
	return d.db.PingContext(ctx)
}

func (d *db) ExecTx(ctx context.Context, f TxFunc) (err error) {
	tx, err := d.BeginTx(ctx)
	if err != nil {
		return err
	}
	defer func() {
		err = tx.Rollback()
		if err == sql.ErrTxDone {
			err = nil
		}
	}()
	err = f(tx)
	if err != nil {
		return err
	}
	err = tx.Commit()
	return err
}

func (d *db) BeginTx(ctx context.Context) (Tx, error) {
	sqlTx, err := d.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	return &tx{d.q.WithTx(sqlTx), sqlTx}, nil
}

type tx struct {
	sqlc.Querier
	tx *sql.Tx
}

func (t *tx) Rollback() error {
	return t.tx.Rollback()
}

func (t *tx) Commit() error {
	return t.tx.Commit()
}
